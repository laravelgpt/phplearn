
import React, { useState, useCallback, useEffect, useMemo, useRef } from 'react';
import { CodeEditor } from './components/CodeEditor';
import { WebView } from './components/WebView';
import { Header, MenuAction } from './components/Header';
import { LearningPath } from './components/LearningPath';
import { Workspace, WorkspaceHandle } from './components/Workspace';
import { Resizer } from './components/Resizer';
import { executePhpCode, getChatResponseStream, lintPhpCode, getAgentBuilderChanges, fixPhpCode, fixAllPhpCode, getComposerPackageInfo, getNpmPackageInfo, getComposerBulkPackageInfo, getNpmBulkPackageInfo, generateCodeInline, editCodeInline } from './services/geminiService';
import { TerminalMessage, MessageType, FileSystemNode, FileNode, DirectoryNode, ChatMessage, BottomTabId, CodeProblem, TerminalInstance, AgentType, AgentAction } from './types';
import { phpTopicsByDay } from './data/phpTopics';
import { useResizablePanel } from './hooks/useResizablePanel';
import { ActivityBar, ActiveLeftPanelId } from './components/ActivityBar';
import { RightActivityBar, ActiveRightPanelId } from './components/RightActivityBar';
import { Chatbot } from './components/Chatbot';
import { Modal, ModalState } from './components/Modal';
import { FileTabs } from './components/FileTabs';
import { NotionNotes } from './components/NotionNotes';
import { BottomPanel } from './components/BottomPanel';

const DEFAULT_FILE_CONTENT = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PHP Test Page</title>
    <style>
        body {
            background-color: #f8fafc; /* slate-50 */
            color: #1e293b; /* slate-800 */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            padding: 2rem;
            transition: background-color 0.2s, color 0.2s;
        }
        .dark body {
            background-color: #0f172a; /* slate-900 */
            color: #f1f5f9; /* slate-100 */
        }
        .container {
            max-width: 800px;
            margin: auto;
            background: white;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            transition: background-color 0.2s, border 0.2s;
        }
        .dark .container {
            background: #1e293b; /* slate-800 */
            box-shadow: none;
            border: 1px solid #334155; /* slate-700 */
        }
        h1 {
            color: #4f46e5; /* indigo-600 */
            transition: color 0.2s;
        }
        .dark h1 {
            color: #818cf8; /* indigo-400 */
        }
        ul { list-style-type: square; padding-left: 20px; }
        .output {
            background: #f1f5f9; /* slate-100 */
            padding: 1rem;
            border-radius: 0.25rem;
            font-family: monospace;
            transition: background-color 0.2s;
        }
        .dark .output {
            background: #334155; /* slate-700 */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Welcome from your Web View!</h1>
        <p>This part of the page is rendered from the HTML in your code editor.</p>
        
        <?php
            // This PHP code will output directly into the HTML.
            echo "<p>Hello, this message was generated by PHP's <strong>echo</strong> command at " . date('Y-m-d H:i:s') . ".</p>";

            $technologies = ["PHP", "React", "Gemini", "Tailwind CSS"];
            echo "<h2>Technologies in this App:</h2>";
            echo "<ul>";
            foreach ($technologies as $tech) {
                echo "<li>" . htmlspecialchars($tech) . "</li>";
            }
            echo "</ul>";

            // The output of this var_dump will appear in the 'Terminal' panel.
            echo "<!-- The next line outputs to the terminal, not the web view. -->";
            var_dump($technologies);
        ?>
    </div>
</body>
</html>
`;

const INITIAL_WORKSPACE: FileSystemNode[] = [
    { id: '1', name: 'index.php', type: 'file', content: DEFAULT_FILE_CONTENT },
    { id: '2', name: 'helpers', type: 'folder', children: [
        { id: '3', name: 'utils.php', type: 'file', content: '<?php\n\nfunction say_hello($name) {\n    return "Hello, " . $name;\n}\n' }
    ]},
];

const WELCOME_MESSAGE: TerminalMessage = {
  type: MessageType.SYSTEM,
  text: "Welcome to the PHP Learning Editor!\nSelect a file to start. Type 'run' or use Ctrl+Enter to execute the code.",
  timestamp: new Date().toLocaleTimeString(),
};

const HELP_MESSAGE = `Available commands:
- run: Executes the PHP code in the active editor.
- php [filename]: Executes a specific PHP file. e.g., 'php index.php'
- clear: Clears this terminal screen.
- help: Shows this help message.
- ls: Lists all files and folders in the workspace.
- cat [path]: Displays the content of a file. e.g., 'cat helpers/utils.php'
- composer require [package]: Adds a new PHP package.
- composer install: Installs dependencies from composer.json.
- composer update [package]: Updates all or a specific PHP package to its latest version.
- npm install [package]: Installs a new or all Node.js packages.
- npm update [package]: Updates all or a specific Node.js package to its latest version.`;

const LOCAL_STORAGE_KEYS = {
    WORKSPACE: 'php-editor-workspace',
    OPEN_FILES: 'php-editor-open-files',
    ACTIVE_FILE: 'php-editor-active-file',
    TERMINALS: 'php-editor-terminals',
    ACTIVE_BOTTOM_TAB: 'php-editor-active-tab',
    THEME: 'php-editor-theme',
    LEFT_PANEL_SIZE: 'php-editor-left-panel-size',
    RIGHT_PANEL_SIZE: 'php-editor-right-panel-size',
    BOTTOM_PANEL_SIZE: 'php-editor-bottom-panel-size',
};


const findNodeRecursive = (nodes: FileSystemNode[], nodeId: string): FileSystemNode | null => {
    for (const node of nodes) {
        if (node.id === nodeId) return node;
        if (node.type === 'folder') {
            const found = findNodeRecursive(node.children, nodeId);
            if (found) return found;
        }
    }
    return null;
};

const findNodeByPath = (path: string, workspace: FileSystemNode[]): FileSystemNode | null => {
    const parts = path.split('/').filter(p => p);
    let currentLevel = workspace;
    let foundNode: FileSystemNode | null = null;

    for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        foundNode = currentLevel.find(node => node.name.toLowerCase() === part.toLowerCase()) || null;

        if (!foundNode) return null;

        if (foundNode.type === 'folder') {
            currentLevel = foundNode.children;
        } else if (i < parts.length - 1) {
            // Path continues but we found a file
            return null;
        }
    }
    return foundNode;
};

const updateFileContentRecursive = (nodes: FileSystemNode[], fileId: string, newContent: string): FileSystemNode[] => {
    return nodes.map(node => {
        if (node.type === 'file' && node.id === fileId) return { ...node, content: newContent };
        if (node.type === 'folder') return { ...node, children: updateFileContentRecursive(node.children, fileId, newContent) };
        return node;
    });
};

const addNodeRecursive = (nodes: FileSystemNode[], parentId: string | null, newNode: FileSystemNode): FileSystemNode[] => {
    if (parentId === null) return [...nodes, newNode];
    return nodes.map(node => {
        if (node.type === 'folder' && node.id === parentId) return { ...node, children: [...node.children, newNode] };
        if (node.type === 'folder') return { ...node, children: addNodeRecursive(node.children, parentId, newNode) };
        return node;
    });
};

const renameNodeRecursive = (nodes: FileSystemNode[], nodeId: string, newName: string): FileSystemNode[] => {
    return nodes.map(node => {
        if (node.id === nodeId) return { ...node, name: newName };
        if (node.type === 'folder') return { ...node, children: renameNodeRecursive(node.children, nodeId, newName) };
        return node;
    });
};

const deleteNodeRecursive = (nodes: FileSystemNode[], nodeId: string): FileSystemNode[] => {
    return nodes.filter(node => node.id !== nodeId).map(node => {
        if (node.type === 'folder') return { ...node, children: deleteNodeRecursive(node.children, nodeId) };
        return node;
    });
};

const findNodeAndParent = (nodes: FileSystemNode[], nodeId: string, parent: DirectoryNode | null = null): { node: FileSystemNode | null; parent: DirectoryNode | null } => {
    for (const node of nodes) {
        if (node.id === nodeId) return { node, parent };
        if (node.type === 'folder') {
            const found = findNodeAndParent(node.children, nodeId, node);
            if (found.node) return found;
        }
    }
    return { node: null, parent: null };
};

const getAllFileIdsRecursive = (node: FileSystemNode): string[] => {
    if (node.type === 'file') {
        return [node.id];
    }
    if (node.type === 'folder') {
        return node.children.flatMap(child => getAllFileIdsRecursive(child));
    }
    return [];
};

const getUniqueNodeName = (siblings: FileSystemNode[], name: string): string => {
    let finalName = name;
    let counter = 1;
    const existingNames = new Set(siblings.map(s => s.name.toLowerCase()));
    
    const parts = name.split('.');
    const hasExtension = parts.length > 1;
    const ext = hasExtension ? `.${parts.pop()}` : '';
    const base = hasExtension ? parts.join('.') : name;

    while (existingNames.has(finalName.toLowerCase())) {
        finalName = `${base} (${counter})${ext}`;
        counter++;
    }
    return finalName;
}

const downloadData = (filename: string, data: string, mimeType: string = 'application/octet-stream') => {
    const blob = new Blob([data], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
};

const formatWorkspaceTree = (nodes: FileSystemNode[], prefix = ''): string => {
    let result = '';
    nodes.forEach((node, index) => {
        const isLast = index === nodes.length - 1;
        const newPrefix = prefix + (isLast ? '    ' : '│   ');
        const connector = isLast ? '└── ' : '├── ';
        result += `${prefix}${connector}${node.name}\n`;
        if (node.type === 'folder' && node.children.length > 0) {
            result += formatWorkspaceTree(node.children, newPrefix);
        }
    });
    return result;
};

const applyAgentActions = (workspace: FileSystemNode[], actions: AgentAction[]): { newWorkspace: FileSystemNode[], errors: string[] } => {
    let newWorkspace = JSON.parse(JSON.stringify(workspace));
    const errors: string[] = [];

    for (const action of actions) {
        const pathParts = action.path.split('/').filter(p => p.trim() !== '');
        if (pathParts.length === 0) {
            errors.push(`Invalid path specified: "${action.path}"`);
            continue;
        }

        const itemName = pathParts.pop()!;
        let currentLevel = newWorkspace;
        let parentNode: DirectoryNode | { children: FileSystemNode[] } = { children: currentLevel };
        
        let parentDirNotFound = false;
        for (const part of pathParts) {
            let nextNode = currentLevel.find((n: FileSystemNode) => n.name.toLowerCase() === part.toLowerCase());
            
            if (nextNode && nextNode.type === 'folder') {
                parentNode = nextNode;
                currentLevel = nextNode.children;
            } else if (nextNode && nextNode.type === 'file') {
                errors.push(`Path is invalid: "${part}" in "${action.path}" is a file, but a directory was expected.`);
                parentDirNotFound = true;
                break;
            } else if (action.type === 'CREATE_FILE' || action.type === 'CREATE_FOLDER') {
                // Directory doesn't exist. Create it on the fly for CREATE actions.
                const newFolder: DirectoryNode = { id: `${Date.now()}-${part}-${Math.random()}`, name: part, type: 'folder', children: [] };
                currentLevel.push(newFolder);
                parentNode = newFolder;
                currentLevel = newFolder.children;
            } else {
                 // For other actions (UPDATE, DELETE), the path must exist.
                errors.push(`Path not found: Directory "${part}" in path "${action.path}" does not exist.`);
                parentDirNotFound = true;
                break;
            }
        }

        if (parentDirNotFound) continue;

        const existingNodeIndex = currentLevel.findIndex((n: FileSystemNode) => n.name.toLowerCase() === itemName.toLowerCase());
        const existingNode = existingNodeIndex > -1 ? currentLevel[existingNodeIndex] : null;

        switch (action.type) {
            case 'CREATE_FOLDER':
                 if (existingNode && existingNode.type === 'file') {
                    errors.push(`Cannot create folder: A file with the name "${itemName}" already exists at this path.`);
                } else if (!existingNode) {
                    currentLevel.push({ id: `${Date.now()}-${itemName}`, name: itemName, type: 'folder', children: [] });
                }
                break;
            case 'CREATE_FILE':
                if (existingNode) errors.push(`Cannot create file: "${action.path}" already exists.`);
                else currentLevel.push({ id: `${Date.now()}-${itemName}`, name: itemName, type: 'file', content: action.content || '' });
                break;
            case 'UPDATE_FILE':
                if (!existingNode) errors.push(`Cannot update file: "${action.path}" not found.`);
                else if (existingNode.type === 'folder') errors.push(`Cannot update: "${action.path}" is a folder.`);
                else (existingNode as FileNode).content = action.content || '';
                break;
            case 'DELETE_FILE':
                if (!existingNode) errors.push(`Cannot delete file: "${action.path}" not found.`);
                else if (existingNode.type === 'folder') errors.push(`Cannot delete: "${action.path}" is a folder.`);
                else currentLevel.splice(existingNodeIndex, 1);
                break;
            case 'DELETE_FOLDER':
                if (!existingNode) errors.push(`Cannot delete folder: "${action.path}" not found.`);
                else if (existingNode.type === 'file') errors.push(`Cannot delete: "${action.path}" is a file.`);
                else currentLevel.splice(existingNodeIndex, 1);
                break;
        }
        
        currentLevel.sort((a, b) => {
            if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;
            return a.name.localeCompare(b.name);
        });
    }

    return { newWorkspace, errors };
};

const App: React.FC = () => {
  const [workspace, setWorkspace] = useState<FileSystemNode[]>(() => {
    try {
        const saved = localStorage.getItem(LOCAL_STORAGE_KEYS.WORKSPACE);
        return saved ? JSON.parse(saved) : INITIAL_WORKSPACE;
    } catch { return INITIAL_WORKSPACE; }
  });

  const [openFileIds, setOpenFileIds] = useState<string[]>(() => {
    try {
        const saved = localStorage.getItem(LOCAL_STORAGE_KEYS.OPEN_FILES);
        return saved ? JSON.parse(saved) : ['1'];
    } catch { return ['1']; }
  });

  const [activeFileId, setActiveFileId] = useState<string | null>(() => {
    try {
        const savedOpen = localStorage.getItem(LOCAL_STORAGE_KEYS.OPEN_FILES);
        const savedActive = localStorage.getItem(LOCAL_STORAGE_KEYS.ACTIVE_FILE);
        const openIds = savedOpen ? JSON.parse(savedOpen) : ['1'];
        const activeId = savedActive ? JSON.parse(savedActive) : null;
        if (activeId && openIds.includes(activeId)) {
            return activeId;
        }
        return openIds[0] || null;
    } catch { return '1'; }
  });

  const [terminals, setTerminals] = useState<TerminalInstance[]>(() => {
    try {
        const saved = localStorage.getItem(LOCAL_STORAGE_KEYS.TERMINALS);
        if(saved && JSON.parse(saved).length > 0) return JSON.parse(saved);
    } catch {}
    const firstTerminalId = `terminal_${Date.now()}`;
    return [{ id: firstTerminalId, name: 'Terminal 1', history: [WELCOME_MESSAGE] }];
  });

  const [webOutput, setWebOutput] = useState<string>('');
  const [isExecuting, setIsExecuting] = useState<boolean>(false);
  
  const [theme, setTheme] = useState<'light' | 'dark'>(() => {
    const saved = localStorage.getItem(LOCAL_STORAGE_KEYS.THEME);
    return (saved === 'light' || saved === 'dark') ? saved : 'dark';
  });

  const [activeLeftPanel, setActiveLeftPanel] = useState<ActiveLeftPanelId | null>('workspace');
  const [activeRightPanel, setActiveRightPanel] = useState<ActiveRightPanelId | null>(null);
  const [isFooterVisible, setFooterVisible] = useState(true);
  const [modalState, setModalState] = useState<ModalState>({ isOpen: false });
  const [isWebViewFullScreen, setWebViewFullScreen] = useState(false);
  
  const [chatMessages, setChatMessages] = useState<ChatMessage[]>([
    { id: 'initial', role: 'model', content: "Hello! I'm your AI Assistant. Choose an agent from the dropdown above and ask me anything about your project."}
  ]);
  const [isAgentTyping, setIsAgentTyping] = useState<boolean>(false);
  const [agentType, setAgentType] = useState<AgentType>('agent');
  const [codeProblems, setCodeProblems] = useState<CodeProblem[]>([]);
  
  const [activeBottomTab, setActiveBottomTab] = useState<BottomTabId>(() => {
    try {
        const savedTab = localStorage.getItem(LOCAL_STORAGE_KEYS.ACTIVE_BOTTOM_TAB);
        const savedTerminals = localStorage.getItem(LOCAL_STORAGE_KEYS.TERMINALS);
        const currentTerminals: TerminalInstance[] = savedTerminals ? JSON.parse(savedTerminals) : [];
        
        if (savedTab) {
            const parsedTab = JSON.parse(savedTab);
            if (parsedTab === 'problems' || currentTerminals.some(t => t.id === parsedTab)) {
                return parsedTab;
            }
        }
        return (currentTerminals[0]?.id) || 'problems';
    } catch {
        return 'problems';
    }
  });

  const [jumpToLine, setJumpToLine] = useState<number | null>(null);
  const [fixingProblemLine, setFixingProblemLine] = useState<number | null>(null);
  const [isFixingAll, setIsFixingAll] = useState<boolean>(false);

  const workspaceRef = useRef<WorkspaceHandle>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const lintTimeoutRef = useRef<number | null>(null);
  
  const { size: leftPanelSize, isResizing: isLeftResizing, handleMouseDown: handleLeftResize } = useResizablePanel({ initialSize: 280, minSize: 240, side: 'left', storageKey: LOCAL_STORAGE_KEYS.LEFT_PANEL_SIZE });
  const { size: rightPanelSize, isResizing: isRightResizing, handleMouseDown: handleRightResize } = useResizablePanel({ initialSize: 480, minSize: 240, side: 'right', storageKey: LOCAL_STORAGE_KEYS.RIGHT_PANEL_SIZE });
  const { size: bottomPanelSize, isResizing: isBottomResizing, handleMouseDown: handleBottomResize } = useResizablePanel({ initialSize: window.innerHeight * 0.35, minSize: 100, side: 'bottom', storageKey: LOCAL_STORAGE_KEYS.BOTTOM_PANEL_SIZE });

  // --- State Persistence Effects ---
  useEffect(() => { localStorage.setItem(LOCAL_STORAGE_KEYS.WORKSPACE, JSON.stringify(workspace)); }, [workspace]);
  useEffect(() => { localStorage.setItem(LOCAL_STORAGE_KEYS.OPEN_FILES, JSON.stringify(openFileIds)); }, [openFileIds]);
  useEffect(() => { localStorage.setItem(LOCAL_STORAGE_KEYS.ACTIVE_FILE, JSON.stringify(activeFileId)); }, [activeFileId]);
  useEffect(() => { localStorage.setItem(LOCAL_STORAGE_KEYS.TERMINALS, JSON.stringify(terminals)); }, [terminals]);
  useEffect(() => { localStorage.setItem(LOCAL_STORAGE_KEYS.ACTIVE_BOTTOM_TAB, JSON.stringify(activeBottomTab)); }, [activeBottomTab]);

  useEffect(() => {
    localStorage.setItem(LOCAL_STORAGE_KEYS.THEME, theme);
    if (theme === 'dark') {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  }, [theme]);
  // --- End of State Persistence Effects ---

  const activeTerminal = useMemo(() => {
    if (activeBottomTab.startsWith('terminal_')) {
        return terminals.find(t => t.id === activeBottomTab) || null;
    }
    return null;
  }, [terminals, activeBottomTab]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isWebViewFullScreen) {
        setWebViewFullScreen(false);
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [isWebViewFullScreen]);
  
  const { activeFileContent, openFiles } = useMemo(() => {
    const findFile = (id: string) => findNodeRecursive(workspace, id) as FileNode | null;
    const activeContent = activeFileId ? findFile(activeFileId)?.content ?? null : null;
    const openFileNodes = openFileIds.map(findFile).filter((f): f is FileNode => f !== null);
    return { activeFileContent: activeContent, openFiles: openFileNodes };
  }, [activeFileId, openFileIds, workspace]);


  useEffect(() => {
    if (lintTimeoutRef.current) {
        clearTimeout(lintTimeoutRef.current);
    }
    if (activeFileContent) {
        lintTimeoutRef.current = window.setTimeout(async () => {
            const problems = await lintPhpCode(activeFileContent);
            
            if (problems.length > 0 && codeProblems.length === 0 && activeBottomTab !== 'problems') {
              setActiveBottomTab('problems');
            }
            setCodeProblems(problems);

        }, 1000); // 1-second debounce
    } else {
        setCodeProblems([]);
    }

    return () => {
        if (lintTimeoutRef.current) {
            clearTimeout(lintTimeoutRef.current);
        }
    };
  }, [activeFileContent, activeBottomTab, codeProblems.length]);


  const addMessageToHistory = useCallback((type: MessageType, text: string, terminalId: string) => {
    setTerminals(prevTerminals => {
        const timestamp = new Date().toLocaleTimeString();
        const newMessage: TerminalMessage = { type, text, timestamp };
        return prevTerminals.map(terminal => 
            terminal.id === terminalId 
                ? { ...terminal, history: [...terminal.history, newMessage] } 
                : terminal
        );
    });
  }, []);

  const handleNewTerminal = useCallback(() => {
    const newId = `terminal_${Date.now()}`;
    const terminalNumbers = terminals.map(t => {
        const match = t.name.match(/Terminal (\d+)/);
        return match ? parseInt(match[1], 10) : 0;
    });
    const nextNumber = terminals.length > 0 ? Math.max(0, ...terminalNumbers) + 1 : 1;

    const newTerminal: TerminalInstance = {
        id: newId,
        name: `Terminal ${nextNumber}`,
        history: [{
            type: MessageType.SYSTEM,
            text: `Welcome to Terminal ${nextNumber}.`,
            timestamp: new Date().toLocaleTimeString(),
        }]
    };
    setTerminals(prev => [...prev, newTerminal]);
    setActiveBottomTab(newId);
    if (!isFooterVisible) {
        setFooterVisible(true);
    }
  }, [terminals, isFooterVisible]);

  const handleRunCode = useCallback(async (codeToRun?: string, fileName?: string) => {
    const code = codeToRun ?? activeFileContent;
    const name = fileName ?? (activeFileId ? (findNodeRecursive(workspace, activeFileId) as FileNode)?.name : 'file');

    if (isExecuting || !code) return;
    
    let terminalToUse = activeTerminal;
    if (!terminalToUse) {
        if (terminals.length > 0) {
            terminalToUse = terminals[0];
            setActiveBottomTab(terminalToUse.id);
            if(!isFooterVisible) setFooterVisible(true);
        } else {
            handleNewTerminal();
            setModalState({ isOpen: true, title: "Terminal Created", content: "A new terminal is ready. Please press 'Run' again to execute your code." });
            return;
        }
    }

    const terminalId = terminalToUse.id;
    setIsExecuting(true);
    addMessageToHistory(MessageType.SYSTEM, `Executing ${name}...`, terminalId);

    const result = await executePhpCode(code);
    
    if (result.terminalOutput) {
        addMessageToHistory(MessageType.PHP_OUTPUT, result.terminalOutput, terminalId);
    } else {
        addMessageToHistory(MessageType.SYSTEM, 'Code executed with no terminal output.', terminalId);
    }
    setWebOutput(result.webOutput);
    setIsExecuting(false);
    if(result.webOutput && !activeRightPanel) {
        setActiveRightPanel('webview');
    }
  }, [activeFileContent, isExecuting, workspace, activeFileId, activeRightPanel, activeTerminal, terminals, addMessageToHistory, handleNewTerminal, isFooterVisible]);
  
  const handleComposerCommand = async (args: string[], terminalId: string) => {
    setIsExecuting(true);
    const [subCommand, ...subArgs] = args;
    const packageName = subArgs[0];

    const composerJsonNode = findNodeByPath('composer.json', workspace) as FileNode | null;
    let composerData: any;

    if (subCommand !== 'require' && !composerJsonNode) {
        addMessageToHistory(MessageType.ERROR, "No composer.json file found. Please create one or use 'composer require'.", terminalId);
        setIsExecuting(false);
        return;
    }
    
    try {
        if(composerJsonNode) composerData = JSON.parse(composerJsonNode.content);
    } catch(e) {
        addMessageToHistory(MessageType.ERROR, "Error parsing composer.json. Please fix it and try again.", terminalId);
        setIsExecuting(false);
        return;
    }

    switch (subCommand) {
        case 'require':
            if (!packageName) {
                addMessageToHistory(MessageType.ERROR, "Usage: composer require [package-name]", terminalId);
                setIsExecuting(false);
                return;
            }
            addMessageToHistory(MessageType.SYSTEM, `Running composer require for "${packageName}"...`, terminalId);
            addMessageToHistory(MessageType.OUTPUT, `> Using AI to find latest version info...`, terminalId);

            const packageInfo = await getComposerPackageInfo(packageName);
            if (!packageInfo) {
                addMessageToHistory(MessageType.ERROR, `Could not find package information for "${packageName}".`, terminalId);
                setIsExecuting(false);
                return;
            }
            
            addMessageToHistory(MessageType.OUTPUT, `> Found ${packageInfo.packageName} version ${packageInfo.latestVersion}. Updating files...`, terminalId);
            composerData = composerJsonNode ? composerData : { require: {} };
            if (!composerData.require) composerData.require = {};
            
            composerData.require[packageInfo.packageName] = packageInfo.latestVersion;
            const newComposerJsonContent = JSON.stringify(composerData, null, 4);
            
            const actions: AgentAction[] = [{
                type: composerJsonNode ? 'UPDATE_FILE' : 'CREATE_FILE',
                path: 'composer.json',
                content: newComposerJsonContent
            }];

            if (!findNodeByPath('vendor/autoload.php', workspace)) {
                actions.push({
                    type: 'CREATE_FILE',
                    path: 'vendor/autoload.php',
                    content: `<?php\n// vendor/autoload.php @generated by Composer\n\nrequire_once __DIR__ . '/composer/autoload_real.php';\n\nreturn ComposerAutoloaderInit::getLoader();\n`
                });
                actions.push({
                    type: 'CREATE_FILE',
                    path: 'vendor/composer/autoload_real.php',
                    content: `<?php\n// autoload_real.php @generated by Composer\nclass ComposerAutoloaderInit { public static function getLoader() { /* MOCKED */ return true; } }`
                });
            }

             actions.push({
                type: 'CREATE_FILE',
                path: `vendor/${packageInfo.packageName}/composer.json`,
                content: JSON.stringify({
                    name: packageInfo.packageName,
                    version: packageInfo.latestVersion.replace(/[^\d.]/g, ''),
                    description: "This is a placeholder package.",
                }, null, 2)
            });

            actions.push({
                type: 'CREATE_FILE',
                path: `vendor/${packageInfo.packageName}/src/index.php`,
                content: `<?php\n// Placeholder file for ${packageInfo.packageName}\n`
            });

            const { newWorkspace, errors } = applyAgentActions(workspace, actions);

            if (errors.length > 0) {
                addMessageToHistory(MessageType.ERROR, `Error updating workspace:\n${errors.join('\n')}`, terminalId);
            } else {
                setWorkspace(newWorkspace);
                addMessageToHistory(MessageType.OUTPUT, `> Installing ${packageInfo.packageName} (${packageInfo.latestVersion})`, terminalId);
                addMessageToHistory(MessageType.SYSTEM, `Successfully installed "${packageName}".`, terminalId);
            }
            break;
        
        case 'install':
             addMessageToHistory(MessageType.SYSTEM, "Installing dependencies from composer.json...", terminalId);
             const packagesToInstall = Object.keys(composerData.require || {});
             if (packagesToInstall.length === 0) {
                 addMessageToHistory(MessageType.OUTPUT, "Nothing to install or update.", terminalId);
                 setIsExecuting(false);
                 return;
             }
             addMessageToHistory(MessageType.OUTPUT, `Found ${packagesToInstall.length} packages. Creating vendor directories...`, terminalId);

             const installActions: AgentAction[] = [];
             if (packagesToInstall.length > 0 && !findNodeByPath('vendor/autoload.php', workspace)) {
                installActions.push({
                    type: 'CREATE_FILE',
                    path: 'vendor/autoload.php',
                    content: `<?php\n// vendor/autoload.php @generated by Composer\n\nrequire_once __DIR__ . '/composer/autoload_real.php';\n\nreturn ComposerAutoloaderInit::getLoader();\n`
                });
                installActions.push({
                    type: 'CREATE_FILE',
                    path: 'vendor/composer/autoload_real.php',
                    content: `<?php\n// autoload_real.php @generated by Composer\nclass ComposerAutoloaderInit { public static function getLoader() { /* MOCKED */ return true; } }`
                });
            }

             packagesToInstall.forEach(pkg => {
                const version = composerData.require[pkg];
                installActions.push({
                    type: 'CREATE_FILE',
                    path: `vendor/${pkg}/composer.json`,
                    content: JSON.stringify({
                        name: pkg,
                        version: version.replace(/[^\d.]/g, ''),
                        description: "This is a placeholder package.",
                    }, null, 2)
                });
                installActions.push({
                    type: 'CREATE_FILE',
                    path: `vendor/${pkg}/src/index.php`,
                    content: `<?php\n// Placeholder file for ${pkg}\n`
                });
             });

             const { newWorkspace: installedWs, errors: installErrors } = applyAgentActions(workspace, installActions);
             if (installErrors.length > 0) addMessageToHistory(MessageType.ERROR, `Workspace errors:\n${installErrors.join('\n')}`, terminalId);
             setWorkspace(installedWs);
             addMessageToHistory(MessageType.SYSTEM, "Installation complete.", terminalId);
             break;

        case 'update':
            const packagesToUpdate = packageName ? [packageName] : Object.keys(composerData.require || {});
            if (packagesToUpdate.length === 0) {
                addMessageToHistory(MessageType.OUTPUT, "No dependencies to update.", terminalId);
                setIsExecuting(false);
                return;
            }

            addMessageToHistory(MessageType.SYSTEM, `Checking for updates for ${packageName || 'all packages'}...`, terminalId);
            addMessageToHistory(MessageType.OUTPUT, "> Using AI to find latest version info...", terminalId);

            const bulkInfo = packageName
                ? [await getComposerPackageInfo(packageName)]
                : await getComposerBulkPackageInfo(packagesToUpdate);

            if (!bulkInfo || bulkInfo.some(p => p === null)) {
                addMessageToHistory(MessageType.ERROR, "Could not fetch update information.", terminalId);
                setIsExecuting(false);
                return;
            }

            let updatesFound = 0;
            const updatedComposerData = JSON.parse(JSON.stringify(composerData));
            
            bulkInfo.forEach(info => {
                if (info && updatedComposerData.require[info.packageName] && updatedComposerData.require[info.packageName] !== info.latestVersion) {
                    addMessageToHistory(MessageType.OUTPUT, `> Updating ${info.packageName} from ${updatedComposerData.require[info.packageName]} to ${info.latestVersion}`, terminalId);
                    updatedComposerData.require[info.packageName] = info.latestVersion;
                    updatesFound++;
                }
            });

            if (updatesFound > 0) {
                const updatedContent = JSON.stringify(updatedComposerData, null, 4);
                setWorkspace(prev => updateFileContentRecursive(prev, composerJsonNode!.id, updatedContent));
                addMessageToHistory(MessageType.SYSTEM, `Update complete. ${updatesFound} package(s) updated in composer.json.`, terminalId);
            } else {
                addMessageToHistory(MessageType.SYSTEM, "All packages are already up to date.", terminalId);
            }
            break;

        default:
            addMessageToHistory(MessageType.ERROR, `Unknown composer command: "${subCommand}". Use 'require', 'install', or 'update'.`, terminalId);
            break;
    }

    setIsExecuting(false);
  };
  
  const handleNpmCommand = async (args: string[], terminalId: string) => {
    setIsExecuting(true);
    const [subCommand, ...subArgs] = args;
    const packageName = subArgs[0];

    if (subCommand !== 'install' && subCommand !== 'i' && subCommand !== 'update') {
        addMessageToHistory(MessageType.ERROR, `Unknown npm command: "${subCommand}". Use 'install' or 'update'.`, terminalId);
        setIsExecuting(false);
        return;
    }

    const packageJsonNode = findNodeByPath('package.json', workspace) as FileNode | null;
    let packageData: any;

    if (!packageJsonNode && (subCommand === 'update' || (subCommand === 'install' && !packageName))) {
        addMessageToHistory(MessageType.ERROR, "No package.json file found. Please create one or use 'npm install [package-name]'.", terminalId);
        setIsExecuting(false);
        return;
    }

    try {
        if(packageJsonNode) packageData = JSON.parse(packageJsonNode.content);
    } catch(e) {
        addMessageToHistory(MessageType.ERROR, "Error parsing package.json. Please fix it and try again.", terminalId);
        setIsExecuting(false);
        return;
    }

    if (subCommand === 'install' || subCommand === 'i') {
        if (packageName) { // Add/install a single package
            addMessageToHistory(MessageType.SYSTEM, `Running npm install for "${packageName}"...`, terminalId);
            addMessageToHistory(MessageType.OUTPUT, `> Using AI to find latest version info...`, terminalId);

            const packageInfo = await getNpmPackageInfo(packageName);
            if (!packageInfo) {
                addMessageToHistory(MessageType.ERROR, `Could not find package information for "${packageName}".`, terminalId);
                setIsExecuting(false);
                return;
            }
            
            addMessageToHistory(MessageType.OUTPUT, `> Found ${packageInfo.packageName} version ${packageInfo.latestVersion}. Updating files...`, terminalId);
            packageData = packageJsonNode ? packageData : { dependencies: {} };
            if (!packageData.dependencies) packageData.dependencies = {};

            packageData.dependencies[packageInfo.packageName] = packageInfo.latestVersion;
            const newPackageJsonContent = JSON.stringify(packageData, null, 2);

            const actions: AgentAction[] = [{
                type: packageJsonNode ? 'UPDATE_FILE' : 'CREATE_FILE',
                path: 'package.json',
                content: newPackageJsonContent
            }, {
                type: 'CREATE_FILE',
                path: `node_modules/${packageInfo.packageName}/package.json`,
                content: JSON.stringify({
                    name: packageInfo.packageName,
                    version: packageInfo.latestVersion.replace(/[^\d.]/g, ''),
                    main: "index.js",
                    description: "This is a placeholder package."
                }, null, 2)
            }, {
                type: 'CREATE_FILE',
                path: `node_modules/${packageInfo.packageName}/index.js`,
                content: `// Placeholder file for ${packageInfo.packageName}\nmodule.exports = {};`
            }];

            const { newWorkspace, errors } = applyAgentActions(workspace, actions);
            if (errors.length > 0) addMessageToHistory(MessageType.ERROR, `Workspace errors:\n${errors.join('\n')}`, terminalId);
            else addMessageToHistory(MessageType.OUTPUT, `+ ${packageInfo.packageName}@${packageInfo.latestVersion}`, terminalId);
            setWorkspace(newWorkspace);
            addMessageToHistory(MessageType.SYSTEM, `Successfully installed "${packageName}".`, terminalId);

        } else { // Install all from package.json
            addMessageToHistory(MessageType.SYSTEM, "Installing dependencies from package.json...", terminalId);
            const packagesToInstall = Object.keys(packageData.dependencies || {});
            if (packagesToInstall.length === 0) {
                addMessageToHistory(MessageType.OUTPUT, "up to date, audited 0 packages", terminalId);
                setIsExecuting(false);
                return;
            }
            addMessageToHistory(MessageType.OUTPUT, `Found ${packagesToInstall.length} packages. Creating node_modules directories...`, terminalId);
            
            const installActions: AgentAction[] = [];
            packagesToInstall.forEach(pkg => {
                const version = packageData.dependencies[pkg];
                installActions.push({
                    type: 'CREATE_FILE',
                    path: `node_modules/${pkg}/package.json`,
                    content: JSON.stringify({
                        name: pkg,
                        version: version.replace(/[^\d.]/g, ''),
                        main: "index.js",
                        description: "This is a placeholder package."
                    }, null, 2)
                });
                installActions.push({
                    type: 'CREATE_FILE',
                    path: `node_modules/${pkg}/index.js`,
                    content: `// Placeholder file for ${pkg}\nmodule.exports = {};`
                });
            });

            const { newWorkspace: installedWs, errors: installErrors } = applyAgentActions(workspace, installActions);
            if (installErrors.length > 0) addMessageToHistory(MessageType.ERROR, `Workspace errors:\n${installErrors.join('\n')}`, terminalId);
            setWorkspace(installedWs);
            addMessageToHistory(MessageType.SYSTEM, "Installation complete.", terminalId);
        }
    } else if (subCommand === 'update') {
        const packagesToUpdate = packageName ? [packageName] : Object.keys(packageData.dependencies || {});
        if (packagesToUpdate.length === 0) {
            addMessageToHistory(MessageType.OUTPUT, "No dependencies to update.", terminalId);
            setIsExecuting(false);
            return;
        }

        addMessageToHistory(MessageType.SYSTEM, `Checking for updates for ${packageName || 'all packages'}...`, terminalId);
        addMessageToHistory(MessageType.OUTPUT, "> Using AI to find latest version info...", terminalId);

        const bulkInfo = packageName
            ? [await getNpmPackageInfo(packageName)]
            : await getNpmBulkPackageInfo(packagesToUpdate);
        
        if (!bulkInfo || bulkInfo.some(p => p === null)) {
            addMessageToHistory(MessageType.ERROR, "Could not fetch update information.", terminalId);
            setIsExecuting(false);
            return;
        }

        let updatesFound = 0;
        const updatedPackageData = JSON.parse(JSON.stringify(packageData));

        bulkInfo.forEach(info => {
            if (info && updatedPackageData.dependencies[info.packageName] && updatedPackageData.dependencies[info.packageName] !== info.latestVersion) {
                addMessageToHistory(MessageType.OUTPUT, `> Updating ${info.packageName} from ${updatedPackageData.dependencies[info.packageName]} to ${info.latestVersion}`, terminalId);
                updatedPackageData.dependencies[info.packageName] = info.latestVersion;
                updatesFound++;
            }
        });

        if (updatesFound > 0) {
            const updatedContent = JSON.stringify(updatedPackageData, null, 2);
            setWorkspace(prev => updateFileContentRecursive(prev, packageJsonNode!.id, updatedContent));
            addMessageToHistory(MessageType.SYSTEM, `Update complete. ${updatesFound} package(s) updated in package.json.`, terminalId);
        } else {
            addMessageToHistory(MessageType.SYSTEM, "All packages are already up to date.", terminalId);
        }
    }
    
    setIsExecuting(false);
  };

  const handleCommand = useCallback((commandStr: string, internal: boolean = false) => {
    if (!activeTerminal) {
       console.error("handleCommand called without an active terminal.");
       return;
    }
    const terminalId = activeTerminal.id;
    const [command, ...args] = commandStr.split(' ');
    if (!internal) addMessageToHistory(MessageType.COMMAND, commandStr, terminalId);

    switch (command.toLowerCase()) {
      case 'run': handleRunCode(); break;
      case 'clear':
        setTerminals(prev => prev.map(t => t.id === terminalId ? {...t, history: [{ type: MessageType.SYSTEM, text: "Terminal cleared.", timestamp: new Date().toLocaleTimeString() }]} : t));
        break;
      case 'help': addMessageToHistory(MessageType.OUTPUT, HELP_MESSAGE, terminalId); break;
      case 'ls': 
        addMessageToHistory(MessageType.OUTPUT, formatWorkspaceTree(workspace), terminalId);
        break;
      case 'cat':
        const path = args.join(' ');
        if (!path) {
            addMessageToHistory(MessageType.ERROR, 'Usage: cat [path]', terminalId);
            break;
        }
        const node = findNodeByPath(path, workspace);
        if (node?.type === 'file') {
            addMessageToHistory(MessageType.OUTPUT, node.content, terminalId);
        } else if (node?.type === 'folder') {
            addMessageToHistory(MessageType.ERROR, `Error: '${path}' is a directory.`, terminalId);
        } else {
            addMessageToHistory(MessageType.ERROR, `Error: File not found at '${path}'.`, terminalId);
        }
        break;
      case 'php':
        const fileToRun = args.join(' ');
        if (!fileToRun) {
            addMessageToHistory(MessageType.ERROR, 'Usage: php [filename]', terminalId);
            break;
        }
        const nodeToRun = findNodeByPath(fileToRun, workspace);
        if (nodeToRun?.type === 'file') {
            handleRunCode(nodeToRun.content, nodeToRun.name);
        } else if (nodeToRun?.type === 'folder') {
            addMessageToHistory(MessageType.ERROR, `Error: '${fileToRun}' is a directory.`, terminalId);
        } else {
            addMessageToHistory(MessageType.ERROR, `Error: File not found at '${fileToRun}'.`, terminalId);
        }
        break;
      case 'composer':
        handleComposerCommand(args, terminalId);
        break;
      case 'npm':
        handleNpmCommand(args, terminalId);
        break;
      default:
        if (!internal) addMessageToHistory(MessageType.ERROR, `Command not found: ${command}`, terminalId);
        break;
    }
  }, [handleRunCode, workspace, activeTerminal, addMessageToHistory, handleComposerCommand, handleNpmCommand]);

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
        if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
            const activeElement = document.activeElement;
            if (activeElement && activeElement.tagName.toLowerCase() !== 'textarea') {
              event.preventDefault();
              handleRunCode();
            }
        }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handleRunCode]);

  const handleSetCode = useCallback((newCode: string) => {
    if (!activeFileId) return;
    setWorkspace(prev => updateFileContentRecursive(prev, activeFileId, newCode));
  }, [activeFileId]);
  
  const handleSelectFile = useCallback((fileId: string) => {
      if (!openFileIds.includes(fileId)) {
          setOpenFileIds(prev => [...prev, fileId]);
      }
      setActiveFileId(fileId);
  }, [openFileIds]);

  const handleNewFileFromDoubleClick = useCallback(() => {
    const getUniqueUntitledName = (siblings: FileSystemNode[]): string => {
        let counter = 1;
        let finalName = `Untitled-${counter}.php`;
        const existingNames = new Set(siblings.map(s => s.name.toLowerCase()));
        while (existingNames.has(finalName.toLowerCase())) {
            counter++;
            finalName = `Untitled-${counter}.php`;
        }
        return finalName;
    };

    const newName = getUniqueUntitledName(workspace);
    const newNode: FileNode = {
        id: Date.now().toString(),
        name: newName,
        type: 'file',
        content: '<?php\n\n'
    };

    setWorkspace(prev => addNodeRecursive(prev, null, newNode));
    handleSelectFile(newNode.id);
  }, [workspace, handleSelectFile]);

  const handleCloseTab = (fileIdToClose: string) => {
      const tabIndex = openFileIds.indexOf(fileIdToClose);
      const newOpenFileIds = openFileIds.filter(id => id !== fileIdToClose);
      setOpenFileIds(newOpenFileIds);
      
      if (activeFileId === fileIdToClose) {
          if (newOpenFileIds.length === 0) {
              setActiveFileId(null);
          } else {
              const newActiveIndex = Math.max(0, tabIndex - 1);
              setActiveFileId(newOpenFileIds[newActiveIndex]);
          }
      }
  };

  const handleNodeCreate = (name: string, type: 'file' | 'folder', parentId: string | null) => {
      if (!name) return false;
      const { parent } = findNodeAndParent(workspace, parentId || '');
      const siblings = parentId ? (findNodeRecursive(workspace, parentId) as DirectoryNode).children : workspace;
      
      if (siblings.some(s => s.name.toLowerCase() === name.toLowerCase())) {
          setModalState({ isOpen: true, title: 'Creation Failed', content: `An item named "${name}" already exists in this directory.`});
          return false;
      }

      const newNode: FileSystemNode = type === 'file'
          ? { id: Date.now().toString(), name, type: 'file', content: '<?php\n\n// New file' }
          : { id: Date.now().toString(), name, type: 'folder', children: [] };
      
      setWorkspace(prev => addNodeRecursive(prev, parentId, newNode));
      if (newNode.type === 'file') {
        handleSelectFile(newNode.id);
      }
      return true;
  };

  const handleNodeRename = (nodeId: string, newName: string) => {
      if (!newName) return false;
      const { node, parent } = findNodeAndParent(workspace, nodeId);
      if (!node) return false;

      const siblings = parent ? parent.children : workspace;
      if (siblings.some(s => s.id !== nodeId && s.name.toLowerCase() === newName.toLowerCase())) {
          setModalState({ isOpen: true, title: 'Rename Failed', content: `An item named "${newName}" already exists in this directory.`});
          return false;
      }

      setWorkspace(prev => renameNodeRecursive(prev, nodeId, newName));
      return true;
  };

  const handleNodeDelete = (nodeId: string) => {
      const { node } = findNodeAndParent(workspace, nodeId);
      if (!node) return;

      const performDelete = () => {
          const idsToClose = getAllFileIdsRecursive(node);
          const newOpenFileIds = openFileIds.filter(id => !idsToClose.includes(id));
          
          if (activeFileId && idsToClose.includes(activeFileId)) {
              const newActiveFileId = newOpenFileIds.length > 0 ? newOpenFileIds[newOpenFileIds.length - 1] : null;
              setActiveFileId(newActiveFileId);
          }
          
          setOpenFileIds(newOpenFileIds);
          setWorkspace(prev => deleteNodeRecursive(prev, nodeId));
          setModalState({ isOpen: false });
      };

      setModalState({
          isOpen: true,
          title: `Delete ${node.type}`,
          content: `Are you sure you want to permanently delete "${node.name}"? This action cannot be undone.`,
          onConfirm: performDelete,
          confirmText: 'Delete',
          isDestructive: true,
      });
  };

  const handleExportNode = (nodeId: string) => {
      const node = findNodeRecursive(workspace, nodeId);
      if (!node) return;
      if (node.type === 'file') {
          downloadData(node.name, node.content);
      } else { // folder
          const json = JSON.stringify(node, null, 2);
          downloadData(`${node.name}.zip.json`, json, 'application/json');
      }
  }

  const handleExportAll = () => {
      const json = JSON.stringify(workspace, null, 2);
      downloadData('workspace.zip.json', json, 'application/json');
  }

  const handleImportTrigger = () => {
      fileInputRef.current?.click();
  };

  const handleFilesImported = async (event: React.ChangeEvent<HTMLInputElement>) => {
      const files = event.target.files;
      if (!files || files.length === 0) return;

      const readFile = (file: File): Promise<FileSystemNode> => {
          return new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = (e) => {
                  try {
                      const content = e.target?.result as string;
                      if (file.name.endsWith('.zip.json')) {
                          const importedNode = JSON.parse(content) as FileSystemNode;
                          resolve(importedNode);
                      } else {
                          const newNode: FileNode = {
                              id: Date.now().toString() + file.name,
                              name: file.name,
                              type: 'file',
                              content: content
                          };
                          resolve(newNode);
                      }
                  } catch (err) {
                      reject(err);
                  }
              };
              reader.onerror = reject;
              reader.readAsText(file);
          });
      };
      
      try {
          const importedNodes = await Promise.all(Array.from(files).map(readFile));
          
          setWorkspace(prevWorkspace => {
              let currentWorkspace = [...prevWorkspace];
              for (const node of importedNodes) {
                  const uniqueName = getUniqueNodeName(currentWorkspace, node.name);
                  const nodeWithUniqueName = { ...node, name: uniqueName, id: Date.now().toString() + uniqueName };
                  currentWorkspace.push(nodeWithUniqueName);
              }
              return currentWorkspace;
          });

          addMessageToHistory(MessageType.SYSTEM, `Successfully imported ${files.length} item(s).`, activeTerminal?.id || terminals[0]?.id);

      } catch (error) {
           console.error("Import failed:", error);
           setModalState({isOpen: true, title: "Import Failed", content: "Could not read or parse one of the files. Please ensure it is a valid text file or a previously exported .zip.json file."});
      }

      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
  };
  
  const handleAgentBuilderMessage = async (message: string, imageData?: { mimeType: string; data: string; }) => {
    setIsAgentTyping(true);
    try {
        const activeFileName = activeFileId ? (findNodeRecursive(workspace, activeFileId) as FileNode)?.name : 'none';
        const agentResponse = await getAgentBuilderChanges(message, chatMessages, workspace, activeFileName, imageData);
        
        const newModelMessage: ChatMessage = {
            id: Date.now().toString(),
            role: 'model',
            content: agentResponse.explanation,
            agentResponse: agentResponse,
            agentResponseStatus: 'pending'
        };
        setChatMessages(prev => [...prev, newModelMessage]);

    } catch (error) {
        console.error("Agent Builder error:", error);
        const errorMessage = error instanceof Error ? error.message : "An unknown error occurred.";
        const newModelMessage: ChatMessage = {
            id: Date.now().toString(),
            role: 'model',
            content: `Sorry, an error occurred while processing your request: ${errorMessage}`,
        };
        setChatMessages(prev => [...prev, newModelMessage]);
    } finally {
        setIsAgentTyping(false);
    }
  };

  const handleStreamingAgentMessage = async (message: string, imageData?: { mimeType: string; data: string; }) => {
    setChatMessages(prev => [...prev, { id: Date.now().toString(), role: 'model', content: '', isStreaming: true }]);
    try {
        const activeFileName = activeFileId ? (findNodeRecursive(workspace, activeFileId) as FileNode)?.name : 'none';
        const stream = await getChatResponseStream(message, chatMessages, workspace, agentType, activeFileName, imageData);
        
        for await (const chunk of stream) {
            const chunkText = chunk.text;
            setChatMessages(prev => {
                const lastMessage = prev[prev.length - 1];
                const updatedLastMessage = { ...lastMessage, content: lastMessage.content + chunkText };
                return [...prev.slice(0, -1), updatedLastMessage];
            });
        }
    } catch (error) {
        console.error("Chatbot error:", error);
        setChatMessages(prev => {
            const lastMessage = prev[prev.length - 1];
            const content = "Sorry, an error occurred while processing your request. Please check the browser console for details.";
            const updatedLastMessage = { ...lastMessage, content };
            return [...prev.slice(0, -1), updatedLastMessage];
        });
    } finally {
        setIsAgentTyping(false);
        setChatMessages(prev => {
            const lastMessage = prev[prev.length - 1];
            if (lastMessage) {
              const updatedLastMessage = { ...lastMessage, isStreaming: false };
              return [...prev.slice(0, -1), updatedLastMessage];
            }
            return prev;
        });
    }
  };

  const handleSendMessage = async (message: string, imageFile: File | null = null) => {
    if ((!message.trim() && !imageFile) || isAgentTyping) return;
    
    setIsAgentTyping(true);

    let imageUrl: string | undefined = undefined;
    let imageData: { mimeType: string; data: string } | undefined = undefined;

    if (imageFile) {
        try {
            const result = await new Promise<{ dataUrl: string, base64: string }>((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => {
                    const dataUrl = e.target?.result as string;
                    const base64 = dataUrl.split(',')[1];
                    resolve({ dataUrl, base64 });
                };
                reader.onerror = reject;
                reader.readAsDataURL(imageFile);
            });
            imageUrl = result.dataUrl;
            imageData = { mimeType: imageFile.type, data: result.base64 };
        } catch(error) {
            console.error("Error reading image file:", error);
            setModalState({isOpen: true, title: "Image Read Error", content: "Could not process the selected image."});
            setIsAgentTyping(false);
            return;
        }
    }

    const newUserMessage: ChatMessage = { id: Date.now().toString(), role: 'user', content: message, imageUrl };
    setChatMessages(prev => [...prev, newUserMessage]);
    
    if (agentType === 'builder') {
        await handleAgentBuilderMessage(message, imageData);
    } else {
        await handleStreamingAgentMessage(message, imageData);
    }
  }
  
  const handleApplyAgentChanges = (messageId: string) => {
      const message = chatMessages.find(m => m.id === messageId);
      if (!message || !message.agentResponse?.actions) return;

      const { newWorkspace, errors } = applyAgentActions(workspace, message.agentResponse.actions);

      if (errors.length > 0) {
          setModalState({
              isOpen: true,
              title: "Error Applying Changes",
              content: (
                  <div>
                      <p>The following errors occurred:</p>
                      <ul className="list-disc list-inside mt-2 text-red-500 text-xs font-mono">
                          {errors.map((e, i) => <li key={i}>{e}</li>)}
                      </ul>
                  </div>
              ),
              isDestructive: true,
          })
          setChatMessages(prev => prev.map(msg => 
              msg.id === messageId ? { ...msg, agentResponseStatus: 'rejected' } : msg
          ));
      } else {
          setWorkspace(newWorkspace);
          setChatMessages(prev => prev.map(msg => 
              msg.id === messageId ? { ...msg, agentResponseStatus: 'applied' } : msg
          ));
          addMessageToHistory(MessageType.SYSTEM, "AI Agent applied changes to the workspace.", activeTerminal?.id || terminals[0]?.id)
      }
  };

  const handleRejectAgentChanges = (messageId: string) => {
       setChatMessages(prev => prev.map(msg => 
          msg.id === messageId ? { ...msg, agentResponseStatus: 'rejected' } : msg
      ));
  };


  const handleCloseTerminal = (terminalId: string) => {
    const terminalToCloseIndex = terminals.findIndex(t => t.id === terminalId);
    if (terminalToCloseIndex === -1) return;

    const newTerminals = terminals.filter(t => t.id !== terminalId);
    
    if (activeBottomTab === terminalId) {
        if (newTerminals.length > 0) {
            const newActiveIndex = Math.max(0, terminalToCloseIndex - 1);
            setActiveBottomTab(newTerminals[newActiveIndex].id);
        } else {
            setActiveBottomTab('problems');
        }
    }
    
    setTerminals(newTerminals);
  };

  const handleClearActiveTerminal = () => {
    if (activeTerminal) {
        setTerminals(prev => prev.map(t => t.id === activeTerminal.id 
            ? {...t, history: [{ type: MessageType.SYSTEM, text: "Terminal cleared.", timestamp: new Date().toLocaleTimeString() }]} 
            : t
        ));
    }
  };

  const handleMenuAction = (action: MenuAction) => {
    const toggleLeftPanel = (panel: ActiveLeftPanelId) => {
        setActiveLeftPanel(p => p === panel ? null : panel);
    };
    const toggleRightPanel = (panel: ActiveRightPanelId) => {
        setActiveRightPanel(p => p === panel ? null : panel);
    }

    switch (action) {
        case 'new-file': workspaceRef.current?.triggerAdd('file', null); break;
        case 'new-folder': workspaceRef.current?.triggerAdd('folder', null); break;
        case 'import-files': handleImportTrigger(); break;
        case 'export-all': handleExportAll(); break;
        case 'run-code': handleRunCode(); break;
        case 'new-terminal': handleNewTerminal(); break;
        case 'toggle-learning-path': toggleLeftPanel('learning'); break;
        case 'toggle-workspace': toggleLeftPanel('workspace'); break;
        case 'toggle-notes': toggleLeftPanel('notes'); break;
        case 'toggle-web-view': toggleRightPanel('webview'); break;
        case 'toggle-code-agent': toggleRightPanel('agent'); break;
        case 'toggle-output': setFooterVisible(p => !p); break;
        case 'clear-terminal': handleClearActiveTerminal(); break;
        case 'show-help': handleCommand('help', true); break;
        case 'toggle-theme': setTheme(t => t === 'dark' ? 'light' : 'dark'); break;
        case 'focus-web-view':
            if(!activeRightPanel) setFooterVisible(true);
            setActiveRightPanel('webview');
            break;
        case 'focus-terminal':
            if(!isFooterVisible) setFooterVisible(true);
            if (terminals.length > 0 && !activeTerminal) {
                setActiveBottomTab(terminals[0].id);
            } else if (terminals.length === 0) {
                handleNewTerminal();
            }
            break;
    }
  };

  const handleTopicSelect = (code: string) => {
    if (!activeFileId) {
        setModalState({isOpen: true, title: 'No Active File', content: "Please select a file to load the topic code into."});
        return;
    }
    handleSetCode(code);
    const activeFileName = (findNodeRecursive(workspace, activeFileId!) as FileNode)?.name;
    addMessageToHistory(MessageType.SYSTEM, `Loaded topic into ${activeFileName}.`, activeTerminal?.id || terminals[0]?.id);
  };
  
  const handleLeftPanelChange = (panel: ActiveLeftPanelId) => {
      setActiveLeftPanel(p => p === panel ? null : panel);
  };
  
  const handleRightPanelChange = (panel: ActiveRightPanelId) => {
      setActiveRightPanel(p => p === panel ? null : panel);
  };

  const handleProblemSelect = (lineNumber: number) => {
    setJumpToLine(lineNumber);
  };

  const handleAutoFix = async (problem: CodeProblem) => {
    if (!activeFileContent) return;

    setFixingProblemLine(problem.line);
    try {
        const result = await fixPhpCode(activeFileContent, problem);
        if (result && result.fixedCode) {
            handleSetCode(result.fixedCode);
            if (activeTerminal) {
                addMessageToHistory(MessageType.SYSTEM, `✅ AI applied auto-fix for problem on line ${problem.line}.`, activeTerminal.id);
            }
        } else {
            setModalState({ isOpen: true, title: "Auto-Fix Failed", content: "The AI could not generate a fix for this problem. Please try fixing it manually." });
        }
    } catch (error) {
        console.error("Auto-fix failed:", error);
        setModalState({ isOpen: true, title: "Error", content: "An unexpected error occurred while attempting to auto-fix." });
    } finally {
        setFixingProblemLine(null);
    }
  };

  const handleAutoFixAll = async () => {
    if (!activeFileContent || codeProblems.length === 0 || isFixingAll || fixingProblemLine !== null) return;

    setIsFixingAll(true);
    const termId = activeTerminal?.id || terminals[0]?.id;
    if (termId) {
        addMessageToHistory(MessageType.SYSTEM, `Attempting to auto-fix all ${codeProblems.length} problems with AI...`, termId);
    }

    try {
        const result = await fixAllPhpCode(activeFileContent, codeProblems);
        if (result && result.fixedCode) {
            handleSetCode(result.fixedCode);
            if (termId) {
                addMessageToHistory(MessageType.SYSTEM, `✅ AI successfully applied fixes for all problems.`, termId);
            }
        } else {
            setModalState({ isOpen: true, title: "Auto-Fix All Failed", content: "The AI could not generate a fix for all problems. Please try fixing them individually." });
             if (termId) {
                addMessageToHistory(MessageType.ERROR, `❌ AI failed to fix all problems.`, termId);
            }
        }
    } catch (error) {
        console.error("Auto-fix all failed:", error);
        setModalState({ isOpen: true, title: "Error", content: "An unexpected error occurred while attempting to auto-fix all problems." });
    } finally {
        setIsFixingAll(false);
    }
  };

  const handleGenerateCodeInline = useCallback(async (prompt: string, position: number) => {
    if (!activeFileId || activeFileContent === null) return;

    const contextStart = Math.max(0, position - 500);
    const contextEnd = Math.min(activeFileContent.length, position + 500);
    const contextCode = activeFileContent.substring(contextStart, contextEnd);

    const result = await generateCodeInline(prompt, contextCode);
    if (result && typeof result.code === 'string') {
        const newCode = activeFileContent.slice(0, position) + result.code + activeFileContent.slice(position);
        handleSetCode(newCode);
    } else {
        setModalState({ isOpen: true, title: 'AI Generation Failed', content: 'Could not generate code for your prompt.' });
    }
  }, [activeFileId, activeFileContent, handleSetCode]);

  const handleGetAiEditSuggestion = useCallback(async (prompt: string, codeToEdit: string): Promise<string | null> => {
    if (!activeFileContent) return null;
    
    const result = await editCodeInline(prompt, codeToEdit, activeFileContent);
    
    if (result && typeof result.code === 'string') {
        return result.code;
    }
    
    setModalState({ isOpen: true, title: 'AI Edit Failed', content: 'Could not edit the code based on your prompt.' });
    return null;

  }, [activeFileContent]);


  const showLeftPanel = activeLeftPanel !== null;
  const showRightPanel = activeRightPanel !== null;
  const isResizing = isLeftResizing || isRightResizing || isBottomResizing;

  if (isWebViewFullScreen) {
    return (
      <div className="h-screen w-screen bg-white dark:bg-slate-950 p-2">
        <WebView 
          htmlContent={webOutput}
          isFullScreen={isWebViewFullScreen}
          onToggleFullScreen={() => setWebViewFullScreen(false)}
          theme={theme}
        />
      </div>
    );
  }

  return (
    <div className="flex flex-col h-screen bg-slate-50 dark:bg-slate-900 text-slate-800 dark:text-slate-200 overflow-hidden">
      {isResizing && <div className="fixed inset-0 z-30 cursor-col-resize" style={{ cursor: isBottomResizing ? 'row-resize' : 'col-resize' }} />}
      <input type="file" ref={fileInputRef} onChange={handleFilesImported} multiple style={{ display: 'none' }} />
      <Modal {...modalState} onClose={() => setModalState({ isOpen: false })} />
      <Header onRun={() => handleRunCode()} isExecuting={isExecuting} hasActiveFile={!!activeFileId} onMenuAction={handleMenuAction} theme={theme} />
      <main className="flex-1 flex flex-row overflow-hidden">
        
        <ActivityBar activePanel={activeLeftPanel} onPanelChange={handleLeftPanelChange} />
        {showLeftPanel && (
            <>
              <div style={{ width: `${leftPanelSize}px` }} className="flex-shrink-0 flex flex-col h-full p-2 pr-0">
                  {activeLeftPanel === 'workspace' && (
                      <div className="h-full">
                          <Workspace ref={workspaceRef} workspace={workspace} activeFileId={activeFileId} onFileSelect={handleSelectFile} onNodeCreate={handleNodeCreate} onNodeRename={handleNodeRename} onNodeDelete={handleNodeDelete} onNodeExport={handleExportNode} />
                      </div>
                  )}
                  {activeLeftPanel === 'learning' && (
                      <div className="h-full">
                          <LearningPath topicsByDay={phpTopicsByDay} onTopicSelect={handleTopicSelect}/>
                      </div>
                  )}
                  {activeLeftPanel === 'notes' && (
                      <div className="h-full">
                          <NotionNotes />
                      </div>
                  )}
              </div>
              <Resizer onMouseDown={handleLeftResize} orientation="vertical" />
            </>
        )}

        <div className="flex-1 flex flex-col min-w-0">
            <div className="flex flex-col flex-1 min-h-0 p-2 pl-0">
                <div className="flex flex-col h-full bg-white dark:bg-slate-900 rounded-lg overflow-hidden">
                    <FileTabs 
                        openFiles={openFiles} 
                        activeFileId={activeFileId} 
                        onTabClick={handleSelectFile} 
                        onTabClose={handleCloseTab} 
                        onNewTabDoubleClick={handleNewFileFromDoubleClick}
                    />
                    <div className="flex-1 min-h-0 border-t border-slate-200 dark:border-slate-700">
                        <CodeEditor 
                          code={activeFileContent} 
                          setCode={handleSetCode} 
                          jumpToLine={jumpToLine}
                          onJumpComplete={() => setJumpToLine(null)}
                          problems={codeProblems}
                          onAutoFix={handleAutoFix}
                          onGenerateCodeInline={handleGenerateCodeInline}
                          onGetAiEditSuggestion={handleGetAiEditSuggestion}
                        />
                    </div>
                </div>
            </div>
          
            {isFooterVisible && <Resizer onMouseDown={handleBottomResize} orientation="horizontal" />}
            {isFooterVisible && (
                <footer className="flex-shrink-0 overflow-hidden" style={{ height: `${bottomPanelSize}px` }}>
                    <div className="h-full p-2 pt-0 pl-0">
                        <BottomPanel
                            terminals={terminals}
                            problems={codeProblems}
                            activeTab={activeBottomTab}
                            onTabChange={setActiveBottomTab}
                            onProblemSelect={handleProblemSelect}
                            onAutoFix={handleAutoFix}
                            fixingProblemLine={fixingProblemLine}
                            onAutoFixAll={handleAutoFixAll}
                            isFixingAll={isFixingAll}
                            onTerminalCommand={handleCommand}
                            isExecuting={isExecuting}
                            onClearTerminal={handleClearActiveTerminal}
                            onClosePanel={() => setFooterVisible(false)}
                            onNewTerminal={handleNewTerminal}
                            onCloseTerminal={handleCloseTerminal}
                        />
                    </div>
                </footer>
            )}
        </div>
        
        {showRightPanel && (
          <>
            <Resizer onMouseDown={handleRightResize} orientation="vertical" />
            <div className="flex-shrink-0 overflow-hidden" style={{ width: `${rightPanelSize}px` }}>
                <div className="w-full h-full p-2 pl-0 flex items-center">
                    {activeRightPanel === 'webview' && (
                        <WebView 
                          htmlContent={webOutput} 
                          isFullScreen={isWebViewFullScreen} 
                          onToggleFullScreen={() => setWebViewFullScreen(p => !p)} 
                          theme={theme}
                        />
                    )}
                    {activeRightPanel === 'agent' && (
                        <Chatbot 
                          messages={chatMessages}
                          onSendMessage={handleSendMessage}
                          isTyping={isAgentTyping}
                          agentType={agentType}
                          onAgentChange={setAgentType}
                          onApplyChanges={handleApplyAgentChanges}
                          onRejectChanges={handleRejectAgentChanges}
                        />
                    )}
                </div>
            </div>
          </>
        )}
        <RightActivityBar activePanel={activeRightPanel} onPanelChange={handleRightPanelChange} />

      </main>
    </div>
  );
};

export default App;
